# 23. Что описывает и показывает Big O нотация как высчитывается, что фактически измеряется, привести примеры.

Big O нотация — это математическая нотация, используемая в информатике для описания асимптотического поведения функций. В контексте алгоритмов и структур данных Big O нотация показывает, как время выполнения алгоритма или объем используемой памяти растут с увеличением размера входных данных (обычно обозначаемого как n). Она помогает оценить эффективность алгоритма и сравнить его с другими алгоритмами.

### Что описывает и показывает Big O нотация?
Big O нотация описывает верхнюю границу роста времени выполнения или объема памяти алгоритма в худшем случае. Она показывает, как алгоритм масштабируется при увеличении размера входных данных.

**Время выполнения**: Сколько шагов или операций требуется алгоритму для выполнения задачи.

**Память**: Сколько дополнительной памяти требуется алгоритму для выполнения задачи.

Big O нотация игнорирует константы и менее значимые члены, фокусируясь на доминирующем факторе, который определяет рост.

### Как высчитывается Big O?
**Определите зависимость от входных данных**:

Найдите, как количество операций или объем памяти зависит от размера входных данных (n).

**Упростите выражение**:

Уберите константы (например, O(2n) становится O(n)).

Оставьте только самый быстрорастущий член (например, O(n^2 + n) становится O(n^2)).

**Используйте стандартные обозначения**:

Например, O(1), O(log n), O(n), O(n log n), O(n^2), O(2^n) и т.д.

### Что фактически измеряется?
**Big O нотация измеряет**:

**Временную сложность (Time Complexity)**:

Сколько времени требуется алгоритму для выполнения задачи в зависимости от размера входных данных.

**Пространственную сложность (Space Complexity)**:

Сколько дополнительной памяти требуется алгоритму для выполнения задачи в зависимости от размера входных данных.

### Примеры Big O нотации:

**1. O(1) — Константная сложность**
Время выполнения или объем памяти не зависят от размера входных данных.

Пример:

```java
int getFirstElement(int[] array) {
    return array[0]; // Всегда выполняется за одно действие
}
```
**2. O(log n) — Логарифмическая сложность**
Время выполнения или объем памяти растут логарифмически с увеличением размера входных данных.

Пример: Бинарный поиск в отсортированном массиве.

```java
int binarySearch(int[] array, int target) {
    int left = 0, right = array.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (array[mid] == target) return mid;
        if (array[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```
**3. O(n) — Линейная сложность**
Время выполнения или объем памяти растут линейно с увеличением размера входных данных.

Пример: Поиск элемента в неотсортированном массиве.

```java
int findElement(int[] array, int target) {
    for (int i = 0; i < array.length; i++) {
        if (array[i] == target) return i;
    }
    return -1;
}
```
**4. O(n log n) — Линейно-логарифмическая сложность**
Время выполнения или объем памяти растут быстрее, чем линейно, но медленнее, чем квадратично.

Пример: Быстрая сортировка (QuickSort) или сортировка слиянием (MergeSort).

```java
void quickSort(int[] array, int low, int high) {
    if (low < high) {
        int pivot = partition(array, low, high);
        quickSort(array, low, pivot - 1);
        quickSort(array, pivot + 1, high);
    }
}
```
**5. O(n^2) — Квадратичная сложность**
Время выполнения или объем памяти растут квадратично с увеличением размера входных данных.

Пример: Сортировка пузырьком (Bubble Sort).

```java
void bubbleSort(int[] array) {
    for (int i = 0; i < array.length - 1; i++) {
        for (int j = 0; j < array.length - i - 1; j++) {
            if (array[j] > array[j + 1]) {
                int temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
}
```
**6. O(2^n) — Экспоненциальная сложность**
Время выполнения или объем памяти растут экспоненциально с увеличением размера входных данных.

Пример: Решение задачи о рюкзаке методом полного перебора.

```java
int knapsack(int[] weights, int[] values, int n, int capacity) {
    if (n == 0 || capacity == 0) return 0;
    if (weights[n - 1] > capacity) return knapsack(weights, values, n - 1, capacity);
    else return Math.max(
        values[n - 1] + knapsack(weights, values, n - 1, capacity - weights[n - 1]),
        knapsack(weights, values, n - 1, capacity)
    );
}
```
**7. O(n!) — Факториальная сложность**
Время выполнения или объем памяти растут факториально с увеличением размера входных данных.

Пример: Решение задачи коммивояжера методом полного перебора.

Пример расчета Big O
Рассмотрим следующий код:

```java
void example(int[] array) {
    for (int i = 0; i < array.length; i++) { // O(n)
        for (int j = 0; j < array.length; j++) { // O(n)
            System.out.println(array[i] + ", " + array[j]);
        }
    }
}
```
Внешний цикл выполняется n раз.

Внутренний цикл выполняется n раз для каждой итерации внешнего цикла.

Общая сложность: O(n * n) = O(n^2).

### Итог
Big O нотация — это мощный инструмент для анализа и сравнения алгоритмов. Она помогает понять, как алгоритм будет вести себя при увеличении объема данных, и выбрать наиболее эффективное решение.
