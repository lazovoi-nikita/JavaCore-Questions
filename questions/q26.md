# 26. Сортировка выбором, сложность, что по памяти.

### Сложность по времени

Худший случай: O(n^2)

Алгоритм всегда выполняет одинаковое количество сравнений, независимо от начального порядка элементов. Для каждого элемента массива выполняется поиск минимального элемента в оставшейся части, что требует O(n) операций. Поскольку это повторяется для каждого из n элементов, общая сложность составляет O(n^2).

Лучший случай: O(n^2)

Даже если массив уже отсортирован, алгоритм все равно выполняет полное количество сравнений.

Средний случай: O(n^2)

В среднем случае количество операций остается квадратичным.

### Сложность по памяти

Память: O(1)

Сортировка выбором является in-place алгоритмом, то есть она не требует дополнительной памяти, пропорциональной размеру входных данных. Все операции выполняются непосредственно в исходном массиве, и используется только константное количество дополнительной памяти для временных переменных (например, для хранения индекса минимального элемента и обмена элементов).

### Как работает сортировка выбором?

Алгоритм делит массив на две части: отсортированную и неотсортированную.

На каждом шаге находится минимальный элемент из неотсортированной части.

Этот минимальный элемент перемещается в конец отсортированной части.

Процесс повторяется, пока весь массив не будет отсортирован.

Пример кода на Java
```java
void selectionSort(int[] array) {
    int n = array.length;
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i; // Индекс минимального элемента
        for (int j = i + 1; j < n; j++) {
            if (array[j] < array[minIndex]) {
                minIndex = j; // Находим новый минимальный элемент
            }
        }
        // Обмен минимального элемента с текущим
        int temp = array[minIndex];
        array[minIndex] = array[i];
        array[i] = temp;
    }
}
```
### Шаги работы на примере
Рассмотрим массив: [64, 25, 12, 22, 11].

**Первый проход**:

Находим минимальный элемент в массиве (11).

Меняем его местами с первым элементом (64).

Массив: [11, 25, 12, 22, 64].

**Второй проход**:

Находим минимальный элемент в оставшейся части (12).

Меняем его местами со вторым элементом (25).

Массив: [11, 12, 25, 22, 64].

**Третий проход**:

Находим минимальный элемент в оставшейся части (22).

Меняем его местами с третьим элементом (25).

Массив: [11, 12, 22, 25, 64].

**Четвертый проход**:

Находим минимальный элемент в оставшейся части (25).

Меняем его местами с четвертым элементом (25).

Массив: [11, 12, 22, 25, 64].

**Массив отсортирован**.

### Когда использовать сортировку выбором?
**Преимущества**:

Простота реализации.

Не требует дополнительной памяти (O(1) по памяти).

Хорошо работает на небольших массивах.

**Недостатки**:

Низкая производительность на больших массивах (O(n^2) по времени).

Не адаптивный: количество операций не уменьшается, если массив частично отсортирован.

**Сортировка выбором подходит для**:

Обучения и понимания основ сортировки.

Очень маленьких массивов.

Ситуаций, когда важно минимизировать количество обменов (например, если обмены дорогостоящи).

### Итог
**Временная сложность**: O(n^2) во всех случаях (худший, лучший, средний).

**Память**: O(1) (in-place алгоритм).

Сортировка выбором — это простой, но неэффективный алгоритм для больших данных. Она полезна для обучения и работы с небольшими массивами.
