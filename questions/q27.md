# 27. Сортировка вставкой, сложность, что по памяти.

### Сложность по времени

Худший случай: O(n^2)

Это происходит, когда массив отсортирован в обратном порядке. В этом случае каждый новый элемент нужно сравнивать и сдвигать все элементы отсортированной части.

Лучший случай: O(n)

Это происходит, когда массив уже отсортирован. В этом случае каждый новый элемент сразу занимает правильное положение, и алгоритм выполняет только n-1 сравнений.

Средний случай: O(n^2)

В среднем случае, даже если массив частично отсортирован, алгоритм все равно выполняет квадратичное количество операций.

### Сложность по памяти

Память: O(1)

Сортировка вставками является in-place алгоритмом, то есть она не требует дополнительной памяти, пропорциональной размеру входных данных. Все операции выполняются непосредственно в исходном массиве, и используется только константное количество дополнительной памяти для временных переменных (например, для хранения текущего элемента).

### Как работает сортировка вставками?

Алгоритм делит массив на две части: отсортированную и неотсортированную.

На каждом шаге берется первый элемент из неотсортированной части и вставляется в правильное место в отсортированной части.

Для этого элемент последовательно сравнивается с элементами отсортированной части, пока не будет найдено его правильное положение.

Процесс повторяется, пока весь массив не будет отсортирован.

Пример кода на Java
```java
void insertionSort(int[] array) {
    int n = array.length;
    for (int i = 1; i < n; i++) {
        int key = array[i]; // Текущий элемент, который нужно вставить
        int j = i - 1;

        // Сдвигаем элементы отсортированной части, чтобы освободить место для key
        while (j >= 0 && array[j] > key) {
            array[j + 1] = array[j];
            j--;
        }
        array[j + 1] = key; // Вставляем key в правильное место
    }
}
```
### Шаги работы на примере
Рассмотрим массив: [12, 11, 13, 5, 6].

**Первый проход**:

Текущий элемент: 11.

Сравниваем с 12 и сдвигаем 12 вправо.

Вставляем 11 на первое место.

Массив: [11, 12, 13, 5, 6].

**Второй проход**:

Текущий элемент: 13.

Он уже находится на правильном месте.

Массив: [11, 12, 13, 5, 6].

**Третий проход**:

Текущий элемент: 5.

Сравниваем с 13, 12, 11 и сдвигаем их вправо.

Вставляем 5 на первое место.

Массив: [5, 11, 12, 13, 6].

**Четвертый проход**:

Текущий элемент: 6.

Сравниваем с 13, 12, 11 и сдвигаем их вправо.

Вставляем 6 на второе место.

Массив: [5, 6, 11, 12, 13].

**Массив отсортирован**.

### Когда использовать сортировку вставками?

**Преимущества**:

Простота реализации.

Эффективна для небольших массивов или частично отсортированных данных.

Не требует дополнительной памяти (O(1) по памяти).

Адаптивная: если массив почти отсортирован, работает быстрее (близко к O(n)).

**Недостатки**:

Низкая производительность на больших массивах (O(n^2) по времени).

### Сортировка вставками подходит для:

Обучения и понимания основ сортировки.

Небольших массивов.

Частично отсортированных данных (например, когда в уже отсортированный массив добавляются новые элементы).

## Итог
**Временная сложность**: O(n^2) в худшем и среднем случаях, O(n) в лучшем случае.

**Память**: O(1) (in-place алгоритм).

Сортировка вставками — это простой и эффективный алгоритм для небольших или частично отсортированных данных. Она также широко используется в более сложных алгоритмах, таких как Timsort (гибридный алгоритм, используемый в Python и Java).

