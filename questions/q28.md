# 28. Быстрая сортировка, сложность, что по памяти.

### **Быстрая сортировка (Quick Sort)**

#### **Сложность по времени**
- **Худший случай**: `O(n^2)`  
  Это происходит, если опорный элемент (pivot) выбирается неудачно (например, всегда минимальный или максимальный элемент). В этом случае массив разбивается на две части, одна из которых пустая, и алгоритм работает как сортировка выбором.

- **Лучший случай**: `O(n log n)`  
  Это происходит, если опорный элемент всегда делит массив на две примерно равные части. В этом случае глубина рекурсии составляет `log n`, и на каждом уровне выполняется `O(n)` операций.

- **Средний случай**: `O(n log n)`  
  В среднем случае, даже если опорный элемент не всегда идеален, алгоритм все равно работает за `O(n log n)`.

#### **Сложность по памяти**
- **Память**: `O(log n)` (в среднем случае)  
  Быстрая сортировка использует рекурсию, и глубина рекурсии зависит от того, как массив разбивается на части. В среднем случае глубина рекурсии составляет `O(log n)`, что требует `O(log n)` дополнительной памяти для стека вызовов.

  В худшем случае (например, при неудачном выборе опорного элемента) глубина рекурсии может достигать `O(n)`, что требует `O(n)` дополнительной памяти.

---

### **Как работает быстрая сортировка?**
1. **Выбор опорного элемента (pivot)**:
   - Опорный элемент выбирается из массива (например, первый, последний, средний или случайный элемент).

2. **Разбиение (partition)**:
   - Массив разбивается на две части: элементы меньше опорного и элементы больше опорного.
   - Опорный элемент занимает свое окончательное место в массиве.

3. **Рекурсия**:
   - Рекурсивно применяется быстрая сортировка к обеим частям массива.

4. **Базовый случай**:
   - Если массив содержит 0 или 1 элемент, он уже отсортирован.

---

### **Пример кода на Java**
```java
void quickSort(int[] array, int low, int high) {
    if (low < high) {
        // Разбиваем массив и получаем индекс опорного элемента
        int pivotIndex = partition(array, low, high);

        // Рекурсивно сортируем левую и правую части
        quickSort(array, low, pivotIndex - 1);
        quickSort(array, pivotIndex + 1, high);
    }
}

int partition(int[] array, int low, int high) {
    int pivot = array[high]; // Выбираем последний элемент как опорный
    int i = low - 1; // Индекс для элемента, меньшего опорного

    for (int j = low; j < high; j++) {
        if (array[j] < pivot) {
            i++;
            // Меняем местами array[i] и array[j]
            int temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }

    // Меняем местами array[i+1] и опорный элемент
    int temp = array[i + 1];
    array[i + 1] = array[high];
    array[high] = temp;

    return i + 1; // Возвращаем индекс опорного элемента
}
```

---

### **Шаги работы на примере**
Рассмотрим массив: `[10, 7, 8, 9, 1, 5]`.

1. **Первый вызов `quickSort`**:
   - Опорный элемент: `5` (последний элемент).
   - После разбиения: `[1, 5, 8, 9, 10, 7]` (опорный элемент `5` на своем месте).

2. **Рекурсивный вызов для левой части**:
   - Левая часть: `[1]`.
   - Уже отсортирована.

3. **Рекурсивный вызов для правой части**:
   - Правая часть: `[8, 9, 10, 7]`.
   - Опорный элемент: `7`.
   - После разбиения: `[7, 9, 10, 8]`.

4. **Рекурсивный вызов для левой части**:
   - Левая часть: `[]` (пустая).
   - Уже отсортирована.

5. **Рекурсивный вызов для правой части**:
   - Правая часть: `[9, 10, 8]`.
   - Опорный элемент: `8`.
   - После разбиения: `[8, 10, 9]`.

6. **Рекурсивный вызов для левой части**:
   - Левая часть: `[]` (пустая).
   - Уже отсортирована.

7. **Рекурсивный вызов для правой части**:
   - Правая часть: `[10, 9]`.
   - Опорный элемент: `9`.
   - После разбиения: `[9, 10]`.

8. **Рекурсивный вызов для левой части**:
   - Левая часть: `[]` (пустая).
   - Уже отсортирована.

9. **Рекурсивный вызов для правой части**:
   - Правая часть: `[10]`.
   - Уже отсортирована.

Итоговый отсортированный массив: `[1, 5, 7, 8, 9, 10]`.

---

### **Когда использовать быструю сортировку?**
- **Преимущества**:
  - Высокая производительность в среднем случае (`O(n log n)`).
  - Эффективна для больших массивов.
  - In-place алгоритм (не требует дополнительной памяти, кроме стека вызовов).

- **Недостатки**:
  - В худшем случае может деградировать до `O(n^2)`.
  - Нестабильная сортировка (меняет порядок элементов с одинаковыми значениями).

Быстрая сортировка подходит для:
- Общего использования, особенно для больших массивов.
- Ситуаций, когда важна средняя производительность, а не гарантированная худшая.

---

### **Итог**
- **Временная сложность**: `O(n log n)` в среднем случае, `O(n^2)` в худшем случае.
- **Память**: `O(log n)` в среднем случае, `O(n)` в худшем случае.
- Быстрая сортировка — это один из самых эффективных алгоритмов сортировки на практике, но требует осторожности при выборе опорного элемента.
