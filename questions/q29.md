# 29. Сортировка слиянием, сложность, что по памяти.

### Сортировка слиянием (Merge Sort)

**Сложность:**
- **Временная сложность:** O(n log n) во всех случаях (худший, средний и лучший).
- **Пространственная сложность:** O(n) из-за использования дополнительной памяти для хранения временных массивов.

### Реализация на Java

```java
public class MergeSort {

    public static void mergeSort(int[] array) {
        if (array == null || array.length <= 1) {
            return;
        }
        int[] temp = new int[array.length];
        mergeSort(array, temp, 0, array.length - 1);
    }

    private static void mergeSort(int[] array, int[] temp, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            mergeSort(array, temp, left, mid);       // Сортировка левой половины
            mergeSort(array, temp, mid + 1, right);  // Сортировка правой половины
            merge(array, temp, left, mid, right);    // Слияние двух половин
        }
    }

    private static void merge(int[] array, int[] temp, int left, int mid, int right) {
        // Копируем элементы во временный массив
        for (int i = left; i <= right; i++) {
            temp[i] = array[i];
        }

        int i = left;       // Индекс начала левой половины
        int j = mid + 1;    // Индекс начала правой половины
        int k = left;      // Индекс для записи в исходный массив

        // Слияние двух половин
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) {
                array[k] = temp[i];
                i++;
            } else {
                array[k] = temp[j];
                j++;
            }
            k++;
        }

        // Копируем оставшиеся элементы левой половины (если есть)
        while (i <= mid) {
            array[k] = temp[i];
            k++;
            i++;
        }
    }

    public static void main(String[] args) {
        int[] array = {38, 27, 43, 3, 9, 82, 10};
        mergeSort(array);
        System.out.println(Arrays.toString(array));
    }
}
```

### Объяснение:
1. **Рекурсия:** Алгоритм делит массив на две половины до тех пор, пока не останутся подмассивы из одного элемента.
2. **Слияние:** Затем происходит слияние двух отсортированных подмассивов в один отсортированный массив.
3. **Временная сложность:** O(n log n), так как массив делится пополам на каждом уровне рекурсии (log n уровней), и на каждом уровне выполняется слияние за O(n).
4. **Пространственная сложность:** O(n), так как используется дополнительный массив для хранения временных данных.

### Преимущества:
- Стабильная сортировка (сохраняет порядок равных элементов).
- Всегда работает за O(n log n), что делает её предсказуемой.

### Недостатки:
- Требует дополнительной памяти O(n), что может быть проблемой для больших данных.

Этот алгоритм часто используется в случаях, когда важна стабильность и предсказуемость времени выполнения.
