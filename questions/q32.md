# 32. Алгоритмы поиска пути: обход в глубину, обход в ширину.

#### Обход в глубину (DFS - Depth-First Search)
DFS исследует граф, двигаясь как можно глубже вдоль каждой ветви перед тем, как вернуться назад. Это можно реализовать как с использованием рекурсии, так и с использованием стека.

#### Обход в ширину (BFS - Breadth-First Search)
BFS исследует граф уровень за уровнем, начиная с начальной вершины. Это можно реализовать с использованием очереди.

---

### Реализация на Java

#### Граф представлен в виде списка смежности

```java
import java.util.*;

public class Graph {
    private int V; // Количество вершин
    private LinkedList<Integer> adj[]; // Список смежности

    // Конструктор
    Graph(int v) {
        V = v;
        adj = new LinkedList[v];
        for (int i = 0; i < v; ++i)
            adj[i] = new LinkedList();
    }

    // Добавление ребра в граф
    void addEdge(int v, int w) {
        adj[v].add(w);
    }

    // Обход в глубину (DFS)
    void DFS(int v) {
        boolean visited[] = new boolean[V]; // Массив для отслеживания посещенных вершин
        DFSUtil(v, visited);
    }

    private void DFSUtil(int v, boolean visited[]) {
        visited[v] = true; // Помечаем текущую вершину как посещенную
        System.out.print(v + " ");

        // Рекурсивно посещаем все смежные вершины
        for (int n : adj[v]) {
            if (!visited[n]) {
                DFSUtil(n, visited);
            }
        }
    }

    // Обход в ширину (BFS)
    void BFS(int v) {
        boolean visited[] = new boolean[V]; // Массив для отслеживания посещенных вершин
        LinkedList<Integer> queue = new LinkedList<>(); // Очередь для BFS

        visited[v] = true;
        queue.add(v);

        while (queue.size() != 0) {
            v = queue.poll(); // Извлекаем вершину из очереди
            System.out.print(v + " ");

            // Добавляем все смежные вершины в очередь
            for (int n : adj[v]) {
                if (!visited[n]) {
                    visited[n] = true;
                    queue.add(n);
                }
            }
        }
    }

    public static void main(String args[]) {
        Graph g = new Graph(6);

        g.addEdge(0, 1);
        g.addEdge(0, 2);
        g.addEdge(1, 3);
        g.addEdge(1, 4);
        g.addEdge(2, 4);
        g.addEdge(3, 4);
        g.addEdge(3, 5);
        g.addEdge(4, 5);

        System.out.println("Обход в глубину (DFS):");
        g.DFS(0);

        System.out.println("\nОбход в ширину (BFS):");
        g.BFS(0);
    }
}
```

---

### Объяснение:

#### Обход в глубину (DFS):
1. **Рекурсивный подход:**
   - Начинаем с заданной вершины.
   - Помечаем вершину как посещенную.
   - Рекурсивно вызываем DFS для всех смежных вершин, которые еще не были посещены.
2. **Используется стек (явно или неявно через рекурсию).**
3. **Применение:**
   - Поиск компонент связности.
   - Топологическая сортировка.
   - Поиск циклов в графе.

#### Обход в ширину (BFS):
1. **Итеративный подход:**
   - Начинаем с заданной вершины.
   - Помещаем вершину в очередь и помечаем как посещенную.
   - Пока очередь не пуста, извлекаем вершину из очереди и добавляем все ее непосещенные смежные вершины в очередь.
2. **Используется очередь.**
3. **Применение:**
   - Поиск кратчайшего пути в невзвешенном графе.
   - Поиск уровней в графе.

---

### Временная сложность:
- **DFS и BFS:** O(V + E), где V — количество вершин, E — количество ребер.

---

### Пространственная сложность:
- **DFS:** O(V) — из-за рекурсии или стека.
- **BFS:** O(V) — из-за очереди.

---

### Пример работы:

Для графа:
```
    0
   / \
  1   2
 / \   \
3   4   4
 \ / \ /
  5   5
```

#### DFS:
- Начинаем с вершины 0.
- Посещаем вершины в порядке: `0 -> 1 -> 3 -> 4 -> 5 -> 2`.

#### BFS:
- Начинаем с вершины 0.
- Посещаем вершины в порядке: `0 -> 1 -> 2 -> 3 -> 4 -> 5`.

---

### Вывод:
- **DFS** подходит для задач, где нужно исследовать граф "вглубь" (например, поиск циклов или компонент связности).
- **BFS** подходит для задач, где нужно исследовать граф "вширь" (например, поиск кратчайшего пути в невзвешенном графе).
