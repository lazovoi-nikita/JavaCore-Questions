# 36. Стек: достоинства, недостатки, временная сложность добавления/поиск/удаления элемента.

Стек (Stack) — это структура данных, работающая по принципу **LIFO (Last In, First Out)** — последний пришел, первый ушел. Это означает, что элемент, добавленный последним, будет удален первым.

---

### **Основные операции стека**

1. **`push`** — добавление элемента на вершину стека.
2. **`pop`** — удаление элемента с вершины стека.
3. **`peek`** (или `top`) — получение элемента с вершины стека без его удаления.
4. **`isEmpty`** — проверка, пуст ли стек.
5. **`size`** — получение количества элементов в стеке.

---

### **Достоинства стека**

1. **Простота реализации:**
   - Стек легко реализовать с использованием массива или связанного списка.

2. **Эффективность операций:**
   - Все основные операции (`push`, `pop`, `peek`) выполняются за **O(1)**.

3. **Полезен для решения определенных задач:**
   - Стек используется в таких задачах, как:
     - Парсинг выражений (например, проверка баланса скобок).
     - Реализация отмены (undo) в приложениях.
     - Обход деревьев и графов (например, DFS).

4. **Ограниченный доступ:**
   - Доступ только к вершине стека, что делает его безопасным для использования в многопоточных приложениях.

---

### **Недостатки стека**

1. **Ограниченная функциональность:**
   - Стек предоставляет доступ только к вершине. Доступ к другим элементам невозможен без удаления элементов.

2. **Фиксированный размер (в случае реализации на массиве):**
   - Если стек реализован на массиве, его размер ограничен. При переполнении требуется создание нового массива и копирование данных.

3. **Не подходит для задач, где требуется доступ к произвольным элементам:**
   - Например, поиск элемента в стеке требует удаления всех элементов до него, что занимает **O(n)**.

---

### **Временная сложность операций**

| Операция       | Временная сложность |
|----------------|---------------------|
| **`push`**     | O(1)                |
| **`pop`**      | O(1)                |
| **`peek`**     | O(1)                |
| **`isEmpty`**  | O(1)                |
| **`size`**     | O(1)                |
| **Поиск элемента** | O(n)           |

---

### **Реализация стека в Java**

#### 1. Использование `Stack` (устаревший класс)
```java
import java.util.Stack;

public class StackExample {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();

        // Добавление элементов
        stack.push(10);
        stack.push(20);
        stack.push(30);

        // Просмотр вершины стека
        System.out.println("Вершина стека: " + stack.peek());

        // Удаление элемента
        System.out.println("Удален элемент: " + stack.pop());

        // Проверка, пуст ли стек
        System.out.println("Стек пуст? " + stack.isEmpty());

        // Размер стека
        System.out.println("Размер стека: " + stack.size());
    }
}
```

#### 2. Использование `Deque` (рекомендуемый способ)
```java
import java.util.ArrayDeque;
import java.util.Deque;

public class StackExample {
    public static void main(String[] args) {
        Deque<Integer> stack = new ArrayDeque<>();

        // Добавление элементов
        stack.push(10);
        stack.push(20);
        stack.push(30);

        // Просмотр вершины стека
        System.out.println("Вершина стека: " + stack.peek());

        // Удаление элемента
        System.out.println("Удален элемент: " + stack.pop());

        // Проверка, пуст ли стек
        System.out.println("Стек пуст? " + stack.isEmpty());

        // Размер стека
        System.out.println("Размер стека: " + stack.size());
    }
}
```

---

### **Сравнение с другими структурами данных**

| Характеристика          | Стек                          | Массив                        | Связанный список               |
|-------------------------|-------------------------------|-------------------------------|--------------------------------|
| Доступ к элементам      | Только вершина (LIFO)         | По индексу (O(1))             | По индексу (O(n))              |
| Вставка/удаление        | O(1) (только на вершине)      | O(n) (сдвиг элементов)        | O(1) (если известен узел)      |
| Память                 | Эффективна (если на массиве)  | Эффективна                   | Требует дополнительной памяти  |
| Использование           | Задачи LIFO (отмена, парсинг) | Фиксированные данные          | Динамические данные            |

---

### **Когда использовать стек?**
1. Когда требуется реализация принципа LIFO.
2. Для задач, связанных с парсингом (например, проверка баланса скобок).
3. Для реализации отмены (undo) в приложениях.
4. Для обхода графов и деревьев (DFS).

---

### **Итог**
Стек — это простая и эффективная структура данных для задач, где требуется доступ только к последнему добавленному элементу. Однако он не подходит для задач, где нужен доступ к произвольным элементам или частый поиск.
