# 37. Очередь: достоинства, недостатки, временная сложность добавления/поиск/удаления элемента.

Очередь (Queue) — это структура данных, работающая по принципу **FIFO (First In, First Out)** — первый пришел, первый ушел. Это означает, что элемент, добавленный первым, будет удален первым.

---

### **Основные операции очереди**

1. **`enqueue`** (или `add`) — добавление элемента в конец очереди.
2. **`dequeue`** (или `remove`) — удаление элемента из начала очереди.
3. **`peek`** (или `element`) — получение элемента из начала очереди без его удаления.
4. **`isEmpty`** — проверка, пуста ли очередь.
5. **`size`** — получение количества элементов в очереди.

---

### **Достоинства очереди**

1. **Простота реализации:**
   - Очередь легко реализовать с использованием массива или связанного списка.

2. **Эффективность операций:**
   - Все основные операции (`enqueue`, `dequeue`, `peek`) выполняются за **O(1)**.

3. **Полезен для решения определенных задач:**
   - Очередь используется в таких задачах, как:
     - Управление задачами (например, планирование процессов в ОС).
     - Реализация BFS (обход в ширину) в графах.
     - Буферизация данных (например, в сетевых протоколах).

4. **Ограниченный доступ:**
   - Доступ только к началу и концу очереди, что делает ее безопасной для использования в многопоточных приложениях.

---

### **Недостатки очереди**

1. **Ограниченная функциональность:**
   - Очередь предоставляет доступ только к началу и концу. Доступ к другим элементам невозможен без удаления элементов.

2. **Фиксированный размер (в случае реализации на массиве):**
   - Если очередь реализована на массиве, ее размер ограничен. При переполнении требуется создание нового массива и копирование данных.

3. **Не подходит для задач, где требуется доступ к произвольным элементам:**
   - Например, поиск элемента в очереди требует удаления всех элементов до него, что занимает **O(n)**.

---

### **Временная сложность операций**

| Операция       | Временная сложность |
|----------------|---------------------|
| **`enqueue`**  | O(1)                |
| **`dequeue`**  | O(1)                |
| **`peek`**     | O(1)                |
| **`isEmpty`**  | O(1)                |
| **`size`**     | O(1)                |
| **Поиск элемента** | O(n)           |

---

### **Реализация очереди в Java**

#### 1. Использование `LinkedList` (реализация интерфейса `Queue`)
```java
import java.util.LinkedList;
import java.util.Queue;

public class QueueExample {
    public static void main(String[] args) {
        Queue<Integer> queue = new LinkedList<>();

        // Добавление элементов
        queue.add(10);
        queue.add(20);
        queue.add(30);

        // Просмотр начала очереди
        System.out.println("Начало очереди: " + queue.peek());

        // Удаление элемента
        System.out.println("Удален элемент: " + queue.remove());

        // Проверка, пуста ли очередь
        System.out.println("Очередь пуста? " + queue.isEmpty());

        // Размер очереди
        System.out.println("Размер очереди: " + queue.size());
    }
}
```

#### 2. Использование `ArrayDeque` (рекомендуемый способ)
```java
import java.util.ArrayDeque;
import java.util.Queue;

public class QueueExample {
    public static void main(String[] args) {
        Queue<Integer> queue = new ArrayDeque<>();

        // Добавление элементов
        queue.add(10);
        queue.add(20);
        queue.add(30);

        // Просмотр начала очереди
        System.out.println("Начало очереди: " + queue.peek());

        // Удаление элемента
        System.out.println("Удален элемент: " + queue.remove());

        // Проверка, пуста ли очередь
        System.out.println("Очередь пуста? " + queue.isEmpty());

        // Размер очереди
        System.out.println("Размер очереди: " + queue.size());
    }
}
```

---

### **Сравнение с другими структурами данных**

| Характеристика          | Очередь                        | Массив                        | Связанный список               |
|-------------------------|-------------------------------|-------------------------------|--------------------------------|
| Доступ к элементам      | Только начало и конец (FIFO)  | По индексу (O(1))             | По индексу (O(n))              |
| Вставка/удаление        | O(1) (только в начало/конец)  | O(n) (сдвиг элементов)        | O(1) (если известен узел)      |
| Память                 | Эффективна (если на массиве)  | Эффективна                   | Требует дополнительной памяти  |
| Использование           | Задачи FIFO (планирование, BFS)| Фиксированные данные          | Динамические данные            |

---

### **Когда использовать очередь?**
1. Когда требуется реализация принципа FIFO.
2. Для задач, связанных с планированием (например, планирование процессов в ОС).
3. Для реализации BFS (обход в ширину) в графах.
4. Для буферизации данных (например, в сетевых протоколах).

---

### **Итог**
Очередь — это простая и эффективная структура данных для задач, где требуется доступ только к первому добавленному элементу. Однако она не подходит для задач, где нужен доступ к произвольным элементам или частый поиск.
