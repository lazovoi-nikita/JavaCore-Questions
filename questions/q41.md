# 41. Что вы знаете о преобразовании примитивных типов данных, есть ли потеря данных, можно ли преобразовать логический тип?

Преобразование примитивных типов данных (type conversion) в Java может происходить как **автоматически** (неявно), так и **вручную** (явно). В зависимости от направления преобразования (от меньшего типа к большему или наоборот), может происходить потеря данных.

---

### **1. Неявное преобразование (Widening Conversion)**

Неявное преобразование происходит автоматически, когда значение меньшего типа присваивается переменной большего типа. При этом **потери данных не происходит**, так как больший тип может вместить все значения меньшего типа.

#### Пример:
```java
int i = 100;
long l = i; // Неявное преобразование int -> long
double d = l; // Неявное преобразование long -> double
```

#### Допустимые неявные преобразования:
- `byte` → `short` → `int` → `long` → `float` → `double`
- `char` → `int` → `long` → `float` → `double`

---

### **2. Явное преобразование (Narrowing Conversion)**

Явное преобразование требуется, когда значение большего типа присваивается переменной меньшего типа. В этом случае возможна **потеря данных**, так как меньший тип может не вместить все значения большего типа. Для явного преобразования используется **приведение типов** (casting).

#### Пример:
```java
double d = 100.04;
long l = (long) d; // Явное преобразование double -> long (потеря дробной части)
int i = (int) l; // Явное преобразование long -> int
```

#### Потеря данных:
- При преобразовании `double` или `float` в целочисленный тип (`int`, `long` и т.д.) теряется дробная часть.
- При преобразовании большего целочисленного типа в меньший (например, `long` → `int`) могут быть потеряны старшие биты.

---

### **3. Преобразование с участием `char`**

Тип `char` может быть неявно преобразован в `int`, `long`, `float` или `double`, так как он является 16-битным беззнаковым целым числом. Однако для преобразования `int` в `char` требуется явное приведение.

#### Пример:
```java
char c = 'A';
int i = c; // Неявное преобразование char -> int (i = 65)
char c2 = (char) i; // Явное преобразование int -> char
```

---

### **4. Преобразование логического типа (`boolean`)**

Логический тип `boolean` **не может быть преобразован** ни в какой другой примитивный тип, и никакой другой примитивный тип не может быть преобразован в `boolean`. Это связано с тем, что `boolean` представляет только два значения: `true` и `false`, и не имеет числового эквивалента.

#### Пример (ошибка):
```java
boolean flag = true;
int i = (int) flag; // Ошибка компиляции!
```

---

### **5. Преобразование с потерей данных**

Потеря данных может происходить в следующих случаях:
1. **Преобразование `float` или `double` в целочисленный тип:**
   - Дробная часть отбрасывается.
   - Пример:
     ```java
     double d = 10.99;
     int i = (int) d; // i = 10
     ```

2. **Преобразование большего целочисленного типа в меньший:**
   - Старшие биты могут быть потеряны.
   - Пример:
     ```java
     int i = 1000;
     byte b = (byte) i; // b = -24 (потеря данных из-за переполнения)
     ```

---

### **6. Автоматическое преобразование в выражениях**

В арифметических выражениях Java автоматически преобразует операнды к общему типу:
- Если один из операндов `double`, другой преобразуется в `double`.
- Если один из операндов `float`, другой преобразуется в `float`.
- Если один из операндов `long`, другой преобразуется в `long`.
- Иначе оба операнда преобразуются в `int`.

#### Пример:
```java
int i = 10;
double d = 20.5;
double result = i + d; // i автоматически преобразуется в double
```

---

### **7. Преобразование с помощью классов-оберток**

Классы-обертки (например, `Integer`, `Double`) позволяют преобразовывать примитивные типы в объекты и наоборот.

#### Пример:
```java
int i = 10;
Integer iObj = i; // Автоупаковка (int -> Integer)
int j = iObj; // Автораспаковка (Integer -> int)
```

---

### **Итог**

1. **Неявное преобразование** происходит автоматически и безопасно (без потери данных).
2. **Явное преобразование** требует приведения типов и может привести к потере данных.
3. **Логический тип `boolean`** не может быть преобразован в другие примитивные типы и наоборот.
4. **Потеря данных** возможна при преобразовании большего типа в меньший (например, `double` → `int`).
5. **Классы-обертки** предоставляют удобные методы для преобразования между примитивными типами и объектами.
