# 48. Иерархия коллекций.

Иерархия коллекций в Java организована вокруг нескольких ключевых интерфейсов и классов. Она является частью Java Collections Framework (JCF), который предоставляет унифицированную архитектуру для работы с группами объектов. Вот основные элементы иерархии:

---

### **1. Интерфейсы**

#### a) **`Collection<E>`**
- Это корневой интерфейс для всех коллекций (кроме `Map`).
- Основные методы:
  - `add(E e)` — добавляет элемент.
  - `remove(Object o)` — удаляет элемент.
  - `contains(Object o)` — проверяет наличие элемента.
  - `size()` — возвращает количество элементов.
  - `iterator()` — возвращает итератор для обхода элементов.

#### b) **`List<E>`**
- Наследуется от `Collection`.
- Упорядоченная коллекция, допускающая дубликаты.
- Основные реализации:
  - `ArrayList` — динамический массив.
  - `LinkedList` — двусвязный список.
- Дополнительные методы:
  - `get(int index)` — возвращает элемент по индексу.
  - `set(int index, E element)` — заменяет элемент по индексу.

#### c) **`Set<E>`**
- Наследуется от `Collection`.
- Коллекция, которая не допускает дубликатов.
- Основные реализации:
  - `HashSet` — множество на основе хэш-таблицы.
  - `TreeSet` — отсортированное множество на основе красно-черного дерева.
- Дополнительные методы:
  - `add(E e)` — добавляет элемент, если его еще нет в множестве.

#### d) **`Queue<E>`**
- Наследуется от `Collection`.
- Коллекция, работающая по принципу FIFO (First In, First Out).
- Основные реализации:
  - `LinkedList` — может использоваться как очередь.
  - `PriorityQueue` — очередь с приоритетом.
- Дополнительные методы:
  - `offer(E e)` — добавляет элемент в очередь.
  - `poll()` — удаляет и возвращает элемент из начала очереди.
  - `peek()` — возвращает элемент из начала очереди без удаления.

#### e) **`Deque<E>`**
- Наследуется от `Queue`.
- Двусторонняя очередь (Double Ended Queue).
- Основные реализации:
  - `ArrayDeque` — реализация на массиве.
  - `LinkedList` — также поддерживает `Deque`.

#### f) **`Map<K, V>`**
- Отдельный интерфейс, не наследуется от `Collection`.
- Хранит пары "ключ-значение".
- Основные реализации:
  - `HashMap` — хэш-таблица.
  - `TreeMap` — отсортированная карта на основе красно-черного дерева.
- Основные методы:
  - `put(K key, V value)` — добавляет пару "ключ-значение".
  - `get(Object key)` — возвращает значение по ключу.
  - `remove(Object key)` — удаляет пару по ключу.

---

### **2. Классы**

#### a) **`ArrayList<E>`**
- Реализация интерфейса `List`.
- Динамический массив.
- Быстрый доступ по индексу, но медленные вставка и удаление в середине списка.

#### b) **`LinkedList<E>`**
- Реализация интерфейсов `List` и `Deque`.
- Двусвязный список.
- Быстрые вставка и удаление, но медленный доступ по индексу.

#### c) **`HashSet<E>`**
- Реализация интерфейса `Set`.
- Множество на основе хэш-таблицы.
- Не сохраняет порядок элементов.

#### d) **`TreeSet<E>`**
- Реализация интерфейса `Set`.
- Отсортированное множество на основе красно-черного дерева.
- Элементы хранятся в отсортированном порядке.

#### e) **`HashMap<K, V>`**
- Реализация интерфейса `Map`.
- Хэш-таблица для хранения пар "ключ-значение".
- Не сохраняет порядок элементов.

#### f) **`TreeMap<K, V>`**
- Реализация интерфейса `Map`.
- Отсортированная карта на основе красно-черного дерева.
- Элементы хранятся в отсортированном порядке по ключам.

#### g) **`PriorityQueue<E>`**
- Реализация интерфейса `Queue`.
- Очередь с приоритетом.
- Элементы упорядочены по приоритету.

---

### **3. Иерархия в виде схемы**

```
Iterable<E>
    |
    +-- Collection<E>
            |
            +-- List<E>
            |       |
            |       +-- ArrayList<E>
            |       +-- LinkedList<E>
            |
            +-- Set<E>
            |       |
            |       +-- HashSet<E>
            |       +-- TreeSet<E>
            |
            +-- Queue<E>
                    |
                    +-- LinkedList<E>
                    +-- PriorityQueue<E>
                    +-- Deque<E>
                            |
                            +-- ArrayDeque<E>

Map<K, V>
    |
    +-- HashMap<K, V>
    +-- TreeMap<K, V>
```

---

### **4. Примеры использования**

#### Пример 1: `ArrayList`
```java
List<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
System.out.println(list); // [Java, Python]
```

#### Пример 2: `HashSet`
```java
Set<String> set = new HashSet<>();
set.add("Java");
set.add("Python");
set.add("Java"); // Дубликат не добавится
System.out.println(set); // [Java, Python]
```

#### Пример 3: `HashMap`
```java
Map<String, Integer> map = new HashMap<>();
map.put("Java", 1);
map.put("Python", 2);
System.out.println(map); // {Java=1, Python=2}
```

#### Пример 4: `PriorityQueue`
```java
Queue<Integer> queue = new PriorityQueue<>();
queue.add(10);
queue.add(5);
queue.add(20);
System.out.println(queue.poll()); // 5 (наивысший приоритет)
```

---

### **5. Преимущества иерархии коллекций**

1. **Универсальность:** Единый интерфейс для работы с различными типами коллекций.
2. **Гибкость:** Возможность выбора подходящей реализации в зависимости от задачи.
3. **Типизация:** Использование generics обеспечивает безопасность типов.
4. **Расширяемость:** Легко добавлять новые реализации коллекций.

---

### **Итог**

Иерархия коллекций в Java организована вокруг интерфейсов `Collection`, `List`, `Set`, `Queue`, `Deque` и `Map`. Каждый интерфейс имеет свои реализации, такие как `ArrayList`, `HashSet`, `HashMap` и другие. Понимание иерархии позволяет выбирать подходящие коллекции для решения конкретных задач.
