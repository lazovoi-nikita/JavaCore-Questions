# 51. Что знаете об коллекциях типа Set?

`Set` — это интерфейс, представляющий коллекцию, которая **не допускает дубликатов элементов**. Он является частью Java Collections Framework (JCF) и используется для хранения уникальных элементов. Основные реализации `Set` в Java — это `HashSet`, `LinkedHashSet` и `TreeSet`.

---

### **1. Основные характеристики `Set`**

- **Уникальность элементов:** `Set` не позволяет хранить дубликаты. Если попытаться добавить элемент, который уже есть в коллекции, он не будет добавлен.
- **Порядок элементов:**
  - `HashSet` — не гарантирует порядок элементов.
  - `LinkedHashSet` — сохраняет порядок вставки элементов.
  - `TreeSet` — хранит элементы в отсортированном порядке.
- **Отсутствие индексов:** Элементы `Set` не имеют индексов, поэтому доступ по индексу невозможен.

---

### **2. Основные реализации `Set`**

#### a) **`HashSet`**
- Внутренне использует **хэш-таблицу** для хранения элементов.
- **Порядок элементов:** Не гарантируется.
- **Время выполнения операций:**
  - Добавление: **O(1)** (в среднем случае).
  - Удаление: **O(1)** (в среднем случае).
  - Поиск: **O(1)** (в среднем случае).
- **Особенности:**
  - Использует метод `hashCode()` для определения места хранения элемента.
  - Если два объекта равны по `equals()`, они не могут быть добавлены в `HashSet`.

#### Пример:
```java
Set<String> hashSet = new HashSet<>();
hashSet.add("Java");
hashSet.add("Python");
hashSet.add("Java"); // Дубликат не добавится
System.out.println(hashSet); // [Java, Python] (порядок не гарантируется)
```

#### b) **`LinkedHashSet`**
- Наследуется от `HashSet`.
- Внутренне использует **хэш-таблицу** и **двусвязный список** для сохранения порядка вставки элементов.
- **Порядок элементов:** Сохраняет порядок вставки.
- **Время выполнения операций:**
  - Добавление: **O(1)** (в среднем случае).
  - Удаление: **O(1)** (в среднем случае).
  - Поиск: **O(1)** (в среднем случае).
- **Особенности:**
  - Подходит для случаев, когда важен порядок добавления элементов.

#### Пример:
```java
Set<String> linkedHashSet = new LinkedHashSet<>();
linkedHashSet.add("Java");
linkedHashSet.add("Python");
linkedHashSet.add("C++");
System.out.println(linkedHashSet); // [Java, Python, C++] (порядок сохранен)
```

#### c) **`TreeSet`**
- Внутренне использует **красно-черное дерево** (сбалансированное бинарное дерево поиска).
- **Порядок элементов:** Элементы хранятся в отсортированном порядке.
- **Время выполнения операций:**
  - Добавление: **O(log n)**.
  - Удаление: **O(log n)**.
  - Поиск: **O(log n)**.
- **Особенности:**
  - Элементы должны быть сравнимы (реализовывать интерфейс `Comparable` или передаваться `Comparator`).
  - Подходит для хранения отсортированных данных.

#### Пример:
```java
Set<String> treeSet = new TreeSet<>();
treeSet.add("Java");
treeSet.add("Python");
treeSet.add("C++");
System.out.println(treeSet); // [C++, Java, Python] (отсортированный порядок)
```

---

### **3. Основные методы `Set`**

- **`add(E e)`:** Добавляет элемент в набор, если его еще нет.
- **`remove(Object o)`:** Удаляет элемент из набора.
- **`contains(Object o)`:** Проверяет наличие элемента в наборе.
- **`size()`:** Возвращает количество элементов в наборе.
- **`isEmpty()`:** Проверяет, пуст ли набор.
- **`iterator()`:** Возвращает итератор для обхода элементов.

---

### **4. Примеры использования**

#### Пример 1: `HashSet`
```java
Set<Integer> numbers = new HashSet<>();
numbers.add(10);
numbers.add(20);
numbers.add(10); // Дубликат не добавится
System.out.println(numbers); // [20, 10] (порядок не гарантируется)
```

#### Пример 2: `LinkedHashSet`
```java
Set<String> fruits = new LinkedHashSet<>();
fruits.add("Apple");
fruits.add("Banana");
fruits.add("Apple"); // Дубликат не добавится
System.out.println(fruits); // [Apple, Banana] (порядок сохранен)
```

#### Пример 3: `TreeSet`
```java
Set<Integer> sortedNumbers = new TreeSet<>();
sortedNumbers.add(30);
sortedNumbers.add(10);
sortedNumbers.add(20);
System.out.println(sortedNumbers); // [10, 20, 30] (отсортированный порядок)
```

---

### **5. Когда использовать `Set`?**

- **`HashSet`:** Когда порядок элементов не важен, и требуется высокая производительность.
- **`LinkedHashSet`:** Когда важен порядок вставки элементов.
- **`TreeSet`:** Когда элементы должны храниться в отсортированном порядке.

---

### **6. Сравнение реализаций `Set`**

| Характеристика          | `HashSet`                      | `LinkedHashSet`                 | `TreeSet`                       |
|-------------------------|--------------------------------|---------------------------------|---------------------------------|
| **Порядок элементов**   | Не гарантируется               | Сохраняет порядок вставки       | Отсортированный порядок         |
| **Внутренняя структура**| Хэш-таблица                    | Хэш-таблица + двусвязный список | Красно-черное дерево            |
| **Время добавления**    | O(1) (в среднем случае)        | O(1) (в среднем случае)         | O(log n)                        |
| **Время удаления**      | O(1) (в среднем случае)        | O(1) (в среднем случае)         | O(log n)                        |
| **Время поиска**        | O(1) (в среднем случае)        | O(1) (в среднем случае)         | O(log n)                        |
| **Использование**       | Уникальные элементы, порядок не важен | Уникальные элементы, порядок важен | Уникальные элементы, сортировка |

---

### **Итог**

- `Set` — это коллекция, которая хранит только уникальные элементы.
- Основные реализации: `HashSet`, `LinkedHashSet`, `TreeSet`.
- `HashSet` — для быстрого доступа, порядок не важен.
- `LinkedHashSet` — для сохранения порядка вставки.
- `TreeSet` — для хранения элементов в отсортированном порядке.

Выбор реализации зависит от требований к порядку элементов и производительности.
