# 56. Расскажите про HashSet.

`HashSet` — это одна из самых популярных реализаций интерфейса `Set` в Java. Он хранит уникальные элементы и использует **хэш-таблицу** для их хранения. Вот основные характеристики и особенности `HashSet`:

---

### **1. Основные характеристики**

- **Уникальность элементов:** `HashSet` не позволяет хранить дубликаты. Если попытаться добавить элемент, который уже есть в коллекции, он не будет добавлен.
- **Порядок элементов:** Порядок элементов в `HashSet` **не гарантируется**. Элементы могут храниться в произвольном порядке.
- **Производительность:** `HashSet` обеспечивает быстрый доступ к элементам благодаря использованию хэш-таблицы.
- **Поддержка `null`:** `HashSet` позволяет хранить один `null`-элемент.

---

### **2. Внутренняя структура**

`HashSet` внутренне использует **хэш-таблицу** для хранения элементов. Хэш-таблица состоит из массива "корзин" (buckets), где каждая корзина может содержать несколько элементов. При добавлении элемента:
1. Вычисляется хэш-код элемента с помощью метода `hashCode()`.
2. На основе хэш-кода определяется индекс корзины.
3. Если в корзине уже есть элементы, происходит проверка на равенство с помощью метода `equals()`.

---

### **3. Основные методы**

- **`add(E e)`:** Добавляет элемент в набор, если его еще нет.
- **`remove(Object o)`:** Удаляет элемент из набора.
- **`contains(Object o)`:** Проверяет наличие элемента в наборе.
- **`size()`:** Возвращает количество элементов в наборе.
- **`isEmpty()`:** Проверяет, пуст ли набор.
- **`iterator()`:** Возвращает итератор для обхода элементов.

---

### **4. Пример использования**

```java
import java.util.HashSet;
import java.util.Set;

public class HashSetExample {
    public static void main(String[] args) {
        Set<String> hashSet = new HashSet<>();

        // Добавление элементов
        hashSet.add("Java");
        hashSet.add("Python");
        hashSet.add("C++");
        hashSet.add("Java"); // Дубликат не добавится

        // Вывод элементов
        System.out.println(hashSet); // [Java, Python, C++] (порядок не гарантируется)

        // Проверка наличия элемента
        System.out.println(hashSet.contains("Python")); // true

        // Удаление элемента
        hashSet.remove("C++");
        System.out.println(hashSet); // [Java, Python]

        // Размер набора
        System.out.println(hashSet.size()); // 2
    }
}
```

---

### **5. Производительность**

- **Добавление элемента:** **O(1)** (в среднем случае).
- **Удаление элемента:** **O(1)** (в среднем случае).
- **Поиск элемента:** **O(1)** (в среднем случае).

В худшем случае (например, при большом количестве коллизий) время выполнения операций может деградировать до **O(n)**.

---

### **6. Особенности**

#### a) **Хэш-код и равенство**
- Для корректной работы `HashSet` элементы должны правильно реализовывать методы `hashCode()` и `equals()`.
- Если два объекта равны по `equals()`, они должны возвращать одинаковый `hashCode()`.

#### Пример:
```java
class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && name.equals(person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}

public class Main {
    public static void main(String[] args) {
        Set<Person> people = new HashSet<>();
        people.add(new Person("Alice", 30));
        people.add(new Person("Bob", 25));
        people.add(new Person("Alice", 30)); // Дубликат не добавится

        System.out.println(people.size()); // 2
    }
}
```

#### b) **Порядок элементов**
- Порядок элементов в `HashSet` не гарантируется. Если важен порядок вставки, используйте `LinkedHashSet`.

#### c) **Поддержка `null`**
- `HashSet` позволяет хранить один `null`-элемент.

---

### **7. Когда использовать `HashSet`?**

- Когда требуется хранить уникальные элементы.
- Когда порядок элементов не важен.
- Когда важна высокая производительность операций добавления, удаления и поиска.

---

### **8. Сравнение с другими реализациями `Set`**

| Характеристика          | `HashSet`                      | `LinkedHashSet`                 | `TreeSet`                       |
|-------------------------|--------------------------------|---------------------------------|---------------------------------|
| **Порядок элементов**   | Не гарантируется               | Сохраняет порядок вставки       | Отсортированный порядок         |
| **Внутренняя структура**| Хэш-таблица                    | Хэш-таблица + двусвязный список | Красно-черное дерево            |
| **Время добавления**    | O(1) (в среднем случае)        | O(1) (в среднем случае)         | O(log n)                        |
| **Время удаления**      | O(1) (в среднем случае)        | O(1) (в среднем случае)         | O(log n)                        |
| **Время поиска**        | O(1) (в среднем случае)        | O(1) (в среднем случае)         | O(log n)                        |
| **Использование**       | Уникальные элементы, порядок не важен | Уникальные элементы, порядок важен | Уникальные элементы, сортировка |

---

### **Итог**

- `HashSet` — это реализация `Set`, которая хранит уникальные элементы с использованием хэш-таблицы.
- Обеспечивает быстрый доступ к элементам (**O(1)** в среднем случае).
- Порядок элементов не гарантируется.
- Подходит для задач, где важна уникальность элементов и высокая производительность.
