# 57. Расскажите про TreeSet/как сортируются элементы.

### **TreeSet в Java**

`TreeSet` — это реализация интерфейса `Set`, которая хранит уникальные элементы в **отсортированном порядке**. Внутренне `TreeSet` использует **красно-черное дерево** (сбалансированное бинарное дерево поиска), что обеспечивает эффективное выполнение операций добавления, удаления и поиска.

---

### **1. Основные характеристики**

- **Уникальность элементов:** `TreeSet` не позволяет хранить дубликаты. Если попытаться добавить элемент, который уже есть в коллекции, он не будет добавлен.
- **Сортировка элементов:** Элементы хранятся в отсортированном порядке. По умолчанию используется **натуральный порядок** (natural ordering), но можно задать собственный порядок с помощью `Comparator`.
- **Производительность:** Операции добавления, удаления и поиска выполняются за **O(log n)**.
- **Поддержка `null`:** `TreeSet` **не позволяет** хранить `null`-элементы, так как `null` нельзя сравнить с другими элементами.

---

### **2. Внутренняя структура**

`TreeSet` внутренне использует **красно-черное дерево** (Red-Black Tree), которое является самобалансирующимся бинарным деревом поиска. Это обеспечивает:
- Быстрый доступ к элементам (**O(log n)**).
- Автоматическую сортировку элементов.

---

### **3. Основные методы**

- **`add(E e)`:** Добавляет элемент в набор, если его еще нет.
- **`remove(Object o)`:** Удаляет элемент из набора.
- **`contains(Object o)`:** Проверяет наличие элемента в наборе.
- **`size()`:** Возвращает количество элементов в наборе.
- **`isEmpty()`:** Проверяет, пуст ли набор.
- **`first()`:** Возвращает первый (наименьший) элемент.
- **`last()`:** Возвращает последний (наибольший) элемент.
- **`iterator()`:** Возвращает итератор для обхода элементов в отсортированном порядке.

---

### **4. Пример использования**

#### Пример 1: Сортировка по натуральному порядку
```java
import java.util.TreeSet;
import java.util.Set;

public class TreeSetExample {
    public static void main(String[] args) {
        Set<String> treeSet = new TreeSet<>();

        // Добавление элементов
        treeSet.add("Java");
        treeSet.add("Python");
        treeSet.add("C++");
        treeSet.add("Java"); // Дубликат не добавится

        // Вывод элементов
        System.out.println(treeSet); // [C++, Java, Python] (отсортированный порядок)

        // Первый и последний элементы
        System.out.println(treeSet.first()); // C++
        System.out.println(treeSet.last());  // Python
    }
}
```

#### Пример 2: Сортировка с помощью `Comparator`
```java
import java.util.TreeSet;
import java.util.Comparator;

public class TreeSetComparatorExample {
    public static void main(String[] args) {
        // Создаем TreeSet с компаратором для сортировки по длине строки
        Set<String> treeSet = new TreeSet<>(Comparator.comparingInt(String::length));

        // Добавление элементов
        treeSet.add("Java");
        treeSet.add("Python");
        treeSet.add("C++");

        // Вывод элементов
        System.out.println(treeSet); // [C++, Java, Python] (отсортировано по длине)
    }
}
```

---

### **5. Как сортируются элементы?**

#### a) **Натуральный порядок (Natural Ordering)**
- Если элементы реализуют интерфейс `Comparable` (например, `String`, `Integer`, `Double`), `TreeSet` использует их метод `compareTo()` для сортировки.
- Пример:
  ```java
  Set<Integer> numbers = new TreeSet<>();
  numbers.add(10);
  numbers.add(5);
  numbers.add(20);
  System.out.println(numbers); // [5, 10, 20]
  ```

#### b) **Пользовательский порядок (Custom Ordering)**
- Если элементы не реализуют `Comparable` или требуется другой порядок сортировки, можно передать `Comparator` в конструктор `TreeSet`.
- Пример:
  ```java
  Set<String> treeSet = new TreeSet<>(Comparator.reverseOrder());
  treeSet.add("Java");
  treeSet.add("Python");
  treeSet.add("C++");
  System.out.println(treeSet); // [Python, Java, C++] (обратный порядок)
  ```

---

### **6. Производительность**

- **Добавление элемента:** **O(log n)**.
- **Удаление элемента:** **O(log n)**.
- **Поиск элемента:** **O(log n)**.

---

### **7. Особенности**

#### a) **Сравнение элементов**
- Элементы должны быть сравнимы (реализовывать `Comparable` или передаваться `Comparator`).
- Если элементы не сравнимы, при добавлении будет выброшено исключение `ClassCastException`.

#### b) **Поддержка `null`**
- `TreeSet` **не поддерживает** `null`-элементы, так как `null` нельзя сравнить с другими элементами.

#### c) **Итерация**
- Итерация по `TreeSet` происходит в отсортированном порядке.

---

### **8. Когда использовать `TreeSet`?**

- Когда требуется хранить уникальные элементы в отсортированном порядке.
- Когда важна производительность операций добавления, удаления и поиска (**O(log n)**).
- Когда требуется доступ к первому или последнему элементу.

---

### **9. Сравнение с другими реализациями `Set`**

| Характеристика          | `HashSet`                      | `LinkedHashSet`                 | `TreeSet`                       |
|-------------------------|--------------------------------|---------------------------------|---------------------------------|
| **Порядок элементов**   | Не гарантируется               | Сохраняет порядок вставки       | Отсортированный порядок         |
| **Внутренняя структура**| Хэш-таблица                    | Хэш-таблица + двусвязный список | Красно-черное дерево            |
| **Время добавления**    | O(1) (в среднем случае)        | O(1) (в среднем случае)         | O(log n)                        |
| **Время удаления**      | O(1) (в среднем случае)        | O(1) (в среднем случае)         | O(log n)                        |
| **Время поиска**        | O(1) (в среднем случае)        | O(1) (в среднем случае)         | O(log n)                        |
| **Использование**       | Уникальные элементы, порядок не важен | Уникальные элементы, порядок важен | Уникальные элементы, сортировка |

---

### **Итог**

- `TreeSet` — это реализация `Set`, которая хранит уникальные элементы в отсортированном порядке.
- Использует красно-черное дерево для обеспечения производительности **O(log n)**.
- Поддерживает сортировку по натуральному порядку или с помощью `Comparator`.
- Подходит для задач, где важна уникальность элементов и их сортировка.
