# 74. Как работать с параллельными потоками с помощью Stream API?

Stream API в Java поддерживает параллельную обработку данных, что позволяет эффективно использовать многопроцессорные системы для ускорения выполнения операций. Параллельные потоки автоматически разделяют работу между несколькими потоками выполнения (threads), что может значительно ускорить обработку больших объемов данных.

---

### **1. Создание параллельного потока**

Параллельный поток можно создать двумя способами:

#### a) **Использование `parallelStream()`**
Метод `parallelStream()` создает параллельный поток из коллекции.

#### Пример:
```java
List<String> languages = Arrays.asList("Java", "Python", "C++", "JavaScript", "Ruby");

List<String> result = languages.parallelStream() // Создаем параллельный поток
    .map(String::toUpperCase) // Преобразуем каждый элемент
    .collect(Collectors.toList()); // Собираем результаты

System.out.println(result); // [JAVA, PYTHON, C++, JAVASCRIPT, RUBY]
```

#### b) **Использование `parallel()`**
Метод `parallel()` преобразует существующий последовательный поток в параллельный.

#### Пример:
```java
List<String> languages = Arrays.asList("Java", "Python", "C++", "JavaScript", "Ruby");

List<String> result = languages.stream()
    .parallel() // Преобразуем поток в параллельный
    .map(String::toUpperCase) // Преобразуем каждый элемент
    .collect(Collectors.toList()); // Собираем результаты

System.out.println(result); // [JAVA, PYTHON, C++, JAVASCRIPT, RUBY]
```

---

### **2. Особенности параллельных потоков**

- **Автоматическое распараллеливание:** Параллельные потоки автоматически разделяют работу между несколькими потоками выполнения.
- **Порядок элементов:** Порядок элементов в параллельном потоке может не сохраняться, если это не требуется явно (например, с помощью `forEachOrdered`).
- **Потокобезопасность:** Операции в параллельных потоках должны быть потокобезопасными. Если используется изменяемое состояние, могут возникнуть проблемы с синхронизацией.

---

### **3. Примеры использования параллельных потоков**

#### a) **Фильтрация и преобразование**
```java
List<String> languages = Arrays.asList("Java", "Python", "C++", "JavaScript", "Ruby");

List<String> result = languages.parallelStream()
    .filter(lang -> lang.length() > 3) // Фильтруем элементы
    .map(String::toUpperCase) // Преобразуем каждый элемент
    .collect(Collectors.toList());

System.out.println(result); // [JAVA, PYTHON, JAVASCRIPT, RUBY]
```

#### b) **Сортировка**
```java
List<String> languages = Arrays.asList("Java", "Python", "C++", "JavaScript", "Ruby");

List<String> result = languages.parallelStream()
    .sorted() // Сортируем элементы
    .collect(Collectors.toList());

System.out.println(result); // [C++, Java, JavaScript, Python, Ruby]
```

#### c) **Агрегация**
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

int sum = numbers.parallelStream()
    .reduce(0, Integer::sum); // Суммируем элементы

System.out.println(sum); // 15
```

---

### **4. Управление параллельными потоками**

#### a) **Использование `forEachOrdered`**
Если порядок элементов важен, используйте `forEachOrdered` вместо `forEach`.

#### Пример:
```java
List<String> languages = Arrays.asList("Java", "Python", "C++", "JavaScript", "Ruby");

languages.parallelStream()
    .forEachOrdered(System.out::println); // Сохраняем порядок элементов
```

#### b) **Использование пользовательского `ForkJoinPool`**
По умолчанию параллельные потоки используют общий `ForkJoinPool`. Если нужно использовать собственный пул потоков, можно создать его вручную.

#### Пример:
```java
ForkJoinPool customPool = new ForkJoinPool(4); // Создаем пул с 4 потоками

customPool.submit(() -> {
    List<String> languages = Arrays.asList("Java", "Python", "C++", "JavaScript", "Ruby");

    List<String> result = languages.parallelStream()
        .map(String::toUpperCase)
        .collect(Collectors.toList());

    System.out.println(result); // [JAVA, PYTHON, C++, JAVASCRIPT, RUBY]
}).join(); // Ждем завершения задачи
```

---

### **5. Когда использовать параллельные потоки?**

- **Большие объемы данных:** Параллельные потоки эффективны для обработки больших объемов данных.
- **Независимые операции:** Операции должны быть независимыми и не требовать синхронизации.
- **Многопроцессорные системы:** Параллельные потоки лучше всего работают на системах с несколькими ядрами процессора.

---

### **6. Ограничения параллельных потоков**

- **Накладные расходы:** Создание и управление потоками выполнения может привести к накладным расходам, особенно для небольших объемов данных.
- **Порядок элементов:** Порядок элементов может не сохраняться, если это не требуется явно.
- **Потокобезопасность:** Необходимо учитывать потокобезопасность операций.

---

### **7. Итог**

- **Параллельные потоки** позволяют эффективно использовать многопроцессорные системы для ускорения обработки данных.
- **Создание:** Используйте `parallelStream()` или `parallel()`.
- **Особенности:** Автоматическое распараллеливание, возможная потеря порядка элементов, необходимость потокобезопасности.
- **Использование:** Для больших объемов данных и независимых операций.

Параллельные потоки — это мощный инструмент, но их следует использовать с осторожностью, учитывая накладные расходы и требования к потокобезопасности.
