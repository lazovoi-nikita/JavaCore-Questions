# 79. Какие ограничения есть у Stream API?

Stream API в Java предоставляет мощный и удобный способ работы с коллекциями и данными, но у него есть определённые ограничения и особенности, которые важно учитывать. Вот основные из них:

---

### 1. **Однократное использование**
Поток (stream) можно использовать только один раз. После вызова терминальной операции (например, `forEach`, `collect`, `reduce`) поток считается потреблённым, и повторное использование вызовет исключение `IllegalStateException`.

Пример:
```java
Stream<Integer> stream = Stream.of(1, 2, 3);
stream.forEach(System.out::println); // ОК
stream.forEach(System.out::println); // Ошибка: поток уже использован
```

---

### 2. **Отсутствие изменяемости**
Stream API не изменяет исходную коллекцию или данные. Все операции (например, `filter`, `map`) возвращают новый поток, а исходные данные остаются неизменными.

Пример:
```java
List<Integer> numbers = List.of(1, 2, 3);
List<Integer> filtered = numbers.stream()
                                .filter(n -> n > 1)
                                .collect(Collectors.toList());
System.out.println(numbers); // [1, 2, 3] (исходный список не изменился)
System.out.println(filtered); // [2, 3]
```

---

### 3. **Ленивые вычисления**
Промежуточные операции (например, `filter`, `map`) выполняются только при вызове терминальной операции. Это может привести к неочевидному поведению, если поток используется неправильно.

Пример:
```java
Stream<Integer> stream = Stream.of(1, 2, 3)
                               .filter(n -> {
                                   System.out.println("Filtering: " + n);
                                   return n > 1;
                               });
// Ничего не выведется, так как терминальная операция не вызвана
stream.forEach(System.out::println); // Только здесь начнётся обработка
```

---

### 4. **Ограниченная поддержка примитивов**
Stream API предоставляет специализированные потоки для примитивов: `IntStream`, `LongStream`, `DoubleStream`. Однако для других примитивов (например, `char`, `float`) таких потоков нет.

Пример:
```java
IntStream intStream = IntStream.of(1, 2, 3); // ОК
// Нет CharStream для работы с char
```

---

### 5. **Параллельные потоки**
Хотя Stream API поддерживает параллельные потоки (через `parallelStream()` или `parallel()`), их использование может быть неэффективным или даже опасным, если:
- Операции не являются потокобезопасными.
- Данные не подходят для параллельной обработки (например, маленькие коллекции).
- Используются операции с побочными эффектами.

Пример:
```java
List<Integer> numbers = List.of(1, 2, 3, 4, 5);
numbers.parallelStream()
       .forEach(System.out::println); // Порядок вывода не гарантируется
```

---

### 6. **Отсутствие доступа к индексам**
Stream API не предоставляет прямого доступа к индексам элементов. Если нужно работать с индексами, приходится использовать обходные пути, например, `IntStream.range`.

Пример:
```java
List<String> names = List.of("Alice", "Bob", "Charlie");
IntStream.range(0, names.size())
         .forEach(i -> System.out.println(i + ": " + names.get(i)));
```

---

### 7. **Ограниченная поддержка ввода-вывода (I/O)**
Stream API не предназначен для работы с потоками ввода-вывода (например, файлами или сетевыми соединениями). Для этого используются другие API, такие как `java.nio.file.Files.lines`.

Пример:
```java
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.stream.Stream;

try (Stream<String> lines = Files.lines(Paths.get("file.txt"))) {
    lines.forEach(System.out::println);
} catch (Exception e) {
    e.printStackTrace();
}
```

---

### 8. **Сложность отладки**
Из-за ленивых вычислений и функционального стиля отладка потоков может быть сложнее, чем традиционного императивного кода. Например, сложно поставить точку останова на промежуточной операции.

---

### 9. **Ограничения на исключения**
Лямбда-выражения в Stream API не могут выбрасывать проверяемые исключения (checked exceptions). Если такое исключение может возникнуть, его нужно обработать внутри лямбды.

Пример:
```java
List<String> files = List.of("file1.txt", "file2.txt");
files.stream()
     .forEach(file -> {
         try {
             Files.readAllLines(Paths.get(file));
         } catch (IOException e) {
             e.printStackTrace();
         }
     });
```

---

### 10. **Производительность**
Stream API может быть менее производительным, чем традиционные циклы, особенно для простых операций на небольших коллекциях. Это связано с накладными расходами на создание и управление потоками.

Пример:
```java
List<Integer> numbers = List.of(1, 2, 3, 4, 5);

// Традиционный цикл
for (int n : numbers) {
    System.out.println(n);
}

// Stream API
numbers.stream().forEach(System.out::println);
```

---

### 11. **Ограниченная поддержка в старых версиях Java**
Stream API появился в Java 8. Если вы работаете с более старыми версиями Java (например, Java 7 или ниже), Stream API недоступен.

---

### 12. **Сложность с пользовательскими операциями**
Если вам нужно выполнить сложные или нестандартные операции, Stream API может оказаться неудобным. В таких случаях проще использовать традиционные циклы или итераторы.

---

### Итог:
Stream API — это мощный инструмент, но он подходит не для всех задач. Основные ограничения:
- Потоки можно использовать только один раз.
- Нет изменяемости исходных данных.
- Ленивые вычисления могут усложнить отладку.
- Ограниченная поддержка примитивов и индексов.
- Параллельные потоки требуют осторожности.
- Производительность может быть ниже, чем у традиционных циклов.

Используйте Stream API там, где он действительно упрощает код, но не забывайте о его ограничениях.
