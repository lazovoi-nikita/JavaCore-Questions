# 8. Можно ли в классе заимплементить 2 интерфейса? А если в них один и тот же метод doSmth? Как он реализуется?

Да, в Java класс может реализовать несколько интерфейсов. Это один из способов, которым Java поддерживает множественное наследование, позволяя классам наследовать поведение из нескольких источников.

## Реализация нескольких интерфейсов

Если класс реализует два интерфейса, и в этих интерфейсах есть методы с одинаковыми именами и параметрами, класс должен предоставить реализацию этого метода. При этом не требуется указывать, из какого интерфейса происходит вызов, так как реализация будет общей для обоих интерфейсов.

Рассмотрим следующий пример, где два интерфейса имеют метод с одинаковым именем:

```java
interface InterfaceA {
    void doSmth();
}

interface InterfaceB {
    void doSmth();
}

class MyClass implements InterfaceA, InterfaceB {
    @Override
    public void doSmth() {
        System.out.println("Implementation of doSmth in MyClass");
    }
}
```
## Объяснение

1. **Интерфейсы**: У нас есть два интерфейса InterfaceA и InterfaceB, каждый из которых объявляет метод doSmth().

2. **Класс MyClass**: Класс MyClass реализует оба интерфейса. Внутри этого класса мы предоставляем реализацию метода doSmth().

3. **Общая реализация**: Поскольку оба интерфейса имеют метод с одинаковым именем и параметрами, в классе MyClass мы можем реализовать его один раз. Эта реализация будет использоваться при вызове метода ```doSmth()``` как из ```InterfaceA```, так и из ```InterfaceB```.

## Использование

Теперь, если вы создадите экземпляр MyClass и вызовете метод doSmth(), он будет работать следующим образом:

```java
public class Main {
    public static void main(String[] args) {
        MyClass myClass = new MyClass();
        myClass.doSmth(); // Вывод: Implementation of doSmth in MyClass
    }
}
```
## Заключение

• В Java класс может реализовать несколько интерфейсов.

• Если в этих интерфейсах есть методы с одинаковыми именами, класс должен предоставить единую реализацию этого метода.

• Это позволяет избежать конфликтов и обеспечивает гибкость в проектировании классов, позволяя им наследовать поведение из разных источников.
