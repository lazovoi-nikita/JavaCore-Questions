# 96. Когда блок finally не будет выполнен?

Блок **`finally`** в Java выполняется практически всегда, но есть несколько исключительных ситуаций, когда он **не будет выполнен**. Эти ситуации связаны с принудительным завершением программы или сбоями на уровне JVM (Java Virtual Machine). Давайте рассмотрим их подробнее.

---

### 1. **Принудительное завершение программы с помощью `System.exit()`**
Если программа завершается принудительно с помощью метода `System.exit()`, блок `finally` не выполняется. Это связано с тем, что `System.exit()` немедленно завершает выполнение программы.

#### Пример:
```java
try {
    System.out.println("Внутри try");
    System.exit(0); // Принудительное завершение программы
} finally {
    System.out.println("Внутри finally"); // Не выполнится
}
```

#### Вывод:
```
Внутри try
```

---

### 2. **Сбой JVM**
Если происходит критическая ошибка на уровне JVM, блок `finally` может не выполниться. Примеры таких ошибок:
- **`OutOfMemoryError`**: Недостаточно памяти для выполнения операции.
- **`StackOverflowError`**: Переполнение стека вызовов.
- **Сбой JVM**: Например, из-за внутренней ошибки виртуальной машины.

#### Пример:
```java
try {
    System.out.println("Внутри try");
    throw new OutOfMemoryError("Недостаточно памяти");
} finally {
    System.out.println("Внутри finally"); // Не выполнится
}
```

#### Вывод:
```
Внутри try
Exception in thread "main" java.lang.OutOfMemoryError: Недостаточно памяти
```

---

### 3. **Бесконечный цикл или зависание**
Если поток выполнения зависает (например, из-за бесконечного цикла или блокировки), блок `finally` не будет выполнен.

#### Пример:
```java
try {
    System.out.println("Внутри try");
    while (true) { // Бесконечный цикл
        // Ничего не делаем
    }
} finally {
    System.out.println("Внутри finally"); // Не выполнится
}
```

#### Вывод:
```
Внутри try
```

---

### 4. **Убийство потока**
Если поток, выполняющий блок `try-finally`, принудительно завершается (например, с помощью устаревшего метода `Thread.stop()`), блок `finally` не будет выполнен.

#### Пример:
```java
Thread thread = new Thread(() -> {
    try {
        System.out.println("Внутри try");
        Thread.sleep(1000); // Имитация работы
    } finally {
        System.out.println("Внутри finally"); // Не выполнится
    }
});

thread.start();
Thread.sleep(100); // Даём потоку время начать выполнение
thread.stop(); // Принудительное завершение потока
```

#### Вывод:
```
Внутри try
```

---

### 5. **Сбой операционной системы**
Если операционная система завершает процесс JVM (например, из-за сбоя или принудительного завершения), блок `finally` не будет выполнен.

---

### 6. **Исключение в конструкторе**
Если исключение возникает в конструкторе объекта до выполнения блока `finally`, блок `finally` не будет выполнен.

#### Пример:
```java
class Resource {
    Resource() {
        throw new RuntimeException("Ошибка в конструкторе");
    }

    void close() {
        System.out.println("Ресурс закрыт");
    }
}

public class Main {
    public static void main(String[] args) {
        Resource resource = null;
        try {
            resource = new Resource(); // Исключение в конструкторе
        } finally {
            if (resource != null) {
                resource.close(); // Не выполнится
            }
        }
    }
}
```

#### Вывод:
```
Exception in thread "main" java.lang.RuntimeException: Ошибка в конструкторе
```

---

### Итог:
Блок `finally` не будет выполнен в следующих случаях:
1. **Принудительное завершение программы** с помощью `System.exit()`.
2. **Сбой JVM**, например, из-за `OutOfMemoryError` или `StackOverflowError`.
3. **Бесконечный цикл или зависание** потока выполнения.
4. **Убийство потока** с помощью методов, таких как `Thread.stop()`.
5. **Сбой операционной системы**, завершающий процесс JVM.
6. **Исключение в конструкторе** до выполнения блока `finally`.

Во всех остальных случаях блок `finally` выполняется гарантированно, что делает его полезным для выполнения cleanup-операций, таких как освобождение ресурсов.
